#!/bin/sh

# This gateway retrieves the output of "show run" command (or its
# equivalent) and prints it onto stdout. When run, it accepts the
# only command on stdin:
#
# * retrieve <endpoint> <handler> <outputfile>
#   (save remote config text into provided local file)

MYDIR=`dirname $0`

decode_error()
{
	case "$1" in
		0)
			echo -n 'success'
		;;
		1)
			echo -n 'internal error 1'
		;;
		2)
			echo -n 'internal error 2'
		;;
		3)
			echo -n 'password not found'
		;;
		4)
			echo -n 'invalid password'
		;;
		5)
			echo -n 'cannot create temporary files'
		;;
		6)
			echo -n 'invalid command'
		;;
		7)
			echo -n 'unknown host OS'
		;;
		*)
			echo -n 'unknown error'
		;;
	esac
}

do_work()
{
	local endpoint=`echo $args | cut -s -d' ' -f1`
	local handler=`echo $args | cut -s -d' ' -f2`
	local conftext=`echo $args | cut -s -d' ' -f3`
	# sanity checks
	if [ -z "$endpoint" -o -z "$conftext" -o -z "$handler" ]; then
		echo 'ERR!too few arguments to connect'
		return
	fi
	[ -x "$MYDIR/$handler.connector" ] || {
		echo "ERR!Handler '$handler' is not available"
		exit 1
	}
	"$MYDIR/$handler.connector" $endpoint "$conftext"
	local ret=$?
	if [ $ret = 0 ]; then
		echo "OK!connected to $endpoint"
	else
		echo -n "ERR!Cannot connect to $endpoint ("
		decode_error $ret
		echo ')'
	fi
}

while read cmd args; do
	case $cmd in
		retrieve)
			do_work $args
			;;
		*)
			echo "ERR!unknown command $cmd"
	esac
done

exit 0
