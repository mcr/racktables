#!/bin/sh

# This is a RackTables gateway for changing switch ports membership
# across VLANs. It works accordingly to the gateway protocol described
# in gateways.php and accepts the following commands on its stdin:
#
# * connect: connect to a switch, fetch all necessary data, store and
#   disconnect
#
# * listvlans: list all VLANs found on the switch, propably filtering
# out those administratively prohibited. Only the VLANs from this
# list will be allowed as new destination for 'set' command.
#
# * listports: list all ports on the switch and their current status.
#   Untagged (switchport mode access) ports will be shown with their
#   VLAN ID and tagged ports will be shown as 'trunk' regardless of
#   how many VLANs they are members of.
#
# * listmacs: output unsorted list of all dynamically learned MAC
#   addresses present on the switch
#

endpoint=
hw=
sw=
user=
handler=
CONNECTED=0
MYDIR=`dirname $0`

authorized()
{
	local endp=$1 user=$2 action=$3 arg1=$4 arg2=$5 skip=yes cval
	[ -z "$endp" -o -z "$user" -o -z "$action" ] && return 1

	# Now we strip PHP wrapping(s) and process auth rules only.
	# Accept more than one ruleset on the floor.
	while read line; do
		if [ "$skip" = "yes" -a "$line" = "# S-T-A-R-T" ]; then
			skip=no
			continue
		fi
		if [ "$skip" = "no" -a "$line" = "# S-T-O-P" ]; then
			skip=yes
			continue
		fi
		[ "$skip" = "yes" ] && continue
		# Allow comments.
		[ -z "${line###*}" ] && continue

		# Parse the line and try to make a decision earliest possible.
		# Username and endpoint must match values/regexps, action
		# must exactly match. Action arguments are tested agains values
		# or regexps, but only for 'change' action.
		# If the current rule doesn't match, advance to the next one.
		# We will fail authorization by default anyway.

		# Test action.
		cval=`echo "$line" | cut -s -d' ' -f3`
		[ "$action" = "$cval" ] || continue

		# Test username.
		cval=`echo "$line" | cut -s -d' ' -f2 | cut -s -d'@' -f1`
		[ -z "${user##$cval}" ] || continue

		# Test endpoint.
		cval=`echo "$line" | cut -s -d' ' -f2 | cut -s -d'@' -f2`
		[ -z "${endp##$cval}" ] || continue

		if [ "$action" = "change" ]; then
			[ -z "$arg1" -o -z "$arg2" ] && return 1
			cval=`echo "$line" | cut -s -d' ' -f4`
			[ -z "${arg1##$cval}" ] || continue
			cval=`echo "$line" | cut -s -d' ' -f5`
			[ -z "${arg2##$cval}" ] || continue
		fi

		# All criterias match. Pick the permission and bail out.
		cval=`echo "$line" | cut -s -d' ' -f1`
		if [ "$cval" = "allow" ]; then
			return 0
		else
			return 1
		fi
	done < "$MYDIR/userauth.php"
	return 1
}

# Not only connect, but gather all the data at once and remember the context.
do_connect()
{
	endpoint=`echo $args | cut -s -d' ' -f1`
	hw=`echo $args | cut -s -d' ' -f2`
	sw=`echo $args | cut -s -d' ' -f3`
	user=`echo $args | cut -s -d' ' -f4`
	# sanity checks
	if [ -z "$endpoint" -o -z "$hw" -o -z "$sw" -o -z "$user" ]; then
		echo 'ERR!too few arguments to connect'
		return
	fi
	case "$sw" in
		Cisco+IOS+12.0|Cisco+IOS+12.2)
			handler=cisco
		;;
		*)
			echo "ERR!Don't know how to handle $sw on $endpoint"
			return
		;;
	esac

	# authorize user, look for "connect" privilege
	if ! authorized $endpoint $user connect; then
		echo "ERR!User $user is not authorized to connect to $endpoint"
		return
	fi

	# prepare temp files
	PORTINFO=`mktemp /tmp/racktables.XXXX`
	if ! [ -f "$PORTINFO" ]; then
		echo 'ERR!could not create portinfo tmpfile'
		return
	fi
	VLANINFO=`mktemp /tmp/racktables.XXXX`
	if ! [ -f "$VLANINFO" ]; then
		echo 'ERR!could not create vlaninfo tmpfile'
		rm -f "$PORTINFO"
		return
	fi
	MACINFO=`mktemp /tmp/racktables.XXXX`
	if ! [ -f "$MACINFO" ]; then
		echo 'ERR!could not create MACinfo tmpfile'
		rm -f "$PORTINFO" "$VLANINFO"
		return
	fi

	# get the data
	"$MYDIR/$handler.connector" $endpoint $hw $sw fetch "$VLANINFO" "$PORTINFO" "$MACINFO"
	ret=$?
	if [ $ret = 0 ]; then
		CONNECTED=1
		echo "OK!connected to $endpoint";
	else
		echo "ERR!Cannot connect to $endpoint, connector returned code $ret"
	fi
}

do_listfile()
{
	local F=$1
	if ! [ -f "$F" ]; then
		echo "ERR!Lost temp file '$F' on the way"
		return
	fi
	echo -n 'OK!'
	local semicolon=''
	# tr might do the work, but use our chance to perform filtering once more
	cat "$F" | while read line; do
		[ "$line" = "" ] && continue
		echo -n "$semicolon$line"
		semicolon=';'
	done
	echo
}

do_set()
{
	# sanity checks
	local setline=$1
	if [ -z "$setline" ]; then
		echo 'ERR!missing set argument'
		return
	fi
	local REQUESTS=`mktemp /tmp/racktables.XXXX`
	local REPLIES=`mktemp /tmp/racktables.XXXX`
	echo $1 | tr ';' '\n' | while read setexpr; do
		portname=`echo $setexpr | cut -s -d'=' -f1`
		newvlan=`echo $setexpr | cut -s -d'=' -f2`
		curvlan=`egrep "^$portname=" $PORTINFO | cut -s -d'=' -f2`
		if [ -z "$curvlan" ]; then
			echo "E!Could not find port $portname" >> "$REPLIES"
			continue
		fi
		if [ "$curvlan" = "trunk" ]; then
			echo "E!Port $portname is a trunk" >> "$REPLIES"
			continue
		fi
		[ "$curvlan" = "$newvlan" ] && continue
		# Authorize user for each change.
		if ! authorized $endpoint $user change $curvlan $newvlan; then
			echo "E!User $user is not authorized to assign port $portname@$endpoint from VLAN $curvlan to VLAN $newvlan" >> "$REPLIES"
			continue
		fi
		echo "$portname $newvlan" >> "$REQUESTS"
	done
	nr=`egrep -c '^.' "$REPLIES"`
	if [ "$nr" -ge 1 ]; then
		echo "W!$nr change request(s) have been ignored" >> "$REPLIES"
	fi

	nq=`egrep -c '^.' "$REQUESTS"`
	if [ "$nq" -ge 1 ]; then
		# Go!
		"$MYDIR/$handler.connector" $endpoint $hw $sw push "$REQUESTS" "$REPLIES" "$MACINFO"
		local ret=$?

		if [ $ret != 0 ]; then
			echo "ERR!Failed to configure $endpoint, connector returned code $ret"
			return
		fi
		echo "I!$nq change request(s) have been processed" >> "$REPLIES"
	fi
	echo -n 'OK!'
	local SEMICOLON=
	while read reply; do
		echo -n $SEMICOLON$reply
		SEMICOLON=';'
		[ -w "$MYDIR/changes.log" ] && echo "$reply" >> "$MYDIR/changes.log"
	done < "$REPLIES"
	echo
	rm -f "$REQUESTS" "$REPLIES"
}

# main loop
while read cmd args; do
	case $cmd in
		connect)
			if [ $CONNECTED = 1 ]; then
				echo 'ERR!Already connected'
			else
				do_connect $args
			fi
			;;
		listvlans)
			if [ $CONNECTED = 1 ]; then
				do_listfile "$VLANINFO"
			else
				echo 'ERR!Not connected'
			fi
			;;
		listports)
			if [ $CONNECTED = 1 ]; then
				do_listfile "$PORTINFO"
			else
				echo 'ERR!Not connected'
			fi
			;;
		listmacs)
			if [ $CONNECTED = 1 ]; then
				do_listfile "$MACINFO"
			else
				echo 'ERR!Not connected'
			fi
			;;
		set)
			if [ $CONNECTED = 1 ]; then
				do_set $args
			else
				echo 'ERR!Not connected'
			fi
			;;
		*)
			echo "ERR!unknown command $cmd"
	esac
done

rm -f "$PORTINFO" "$VLANINFO" "$MACINFO"
exit 0
